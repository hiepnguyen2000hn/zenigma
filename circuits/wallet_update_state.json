{
  "noir_version": "0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab",
  "hash": 1296104943700109705,
  "abi": {
    "parameters": [
      {
        "name": "old_wallet_commitment",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      },
      {
        "name": "new_wallet_commitment",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      },
      {
        "name": "old_merkle_root",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      },
      {
        "name": "transfer_direction",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      },
      {
        "name": "transfer_mint",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      },
      {
        "name": "transfer_amount",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      },
      {
        "name": "operation_type",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      },
      {
        "name": "old_wallet",
        "type": {
          "kind": "struct",
          "path": "common::data::Wallet",
          "fields": [
            {
              "name": "available_balances",
              "type": {
                "kind": "array",
                "length": 10,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "reserved_balances",
              "type": {
                "kind": "array",
                "length": 10,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "orders_list",
              "type": {
                "kind": "array",
                "length": 4,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "fees",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "keys",
              "type": {
                "kind": "struct",
                "path": "common::data::PublicKeyChain",
                "fields": [
                  {
                    "name": "pk_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "pk_match",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ]
              }
            },
            {
              "name": "blinder",
              "type": {
                "kind": "field"
              }
            }
          ]
        },
        "visibility": "private"
      },
      {
        "name": "old_index",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "old_hash_path",
        "type": {
          "kind": "array",
          "length": 16,
          "type": {
            "kind": "field"
          }
        },
        "visibility": "private"
      },
      {
        "name": "new_blinder",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "transfer_index",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "order_index",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "order_direction",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "order_price",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "order_quantity",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "order_token_in",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "order_token_out",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "order_operation_type",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "field"
      },
      "visibility": "public"
    },
    "error_types": {}
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "25": {
      "source": "use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "26": {
      "source": "pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n",
      "path": "std/field/mod.nr"
    },
    "72": {
      "source": "use dep::poseidon::poseidon2::Poseidon2;\nuse crate::constants::GLOBAL_DEPTH;\n\npub fn excute_merkle_root(\n    commitment: Field,\n    hash_path: [Field; GLOBAL_DEPTH],\n    index: u32,\n) -> Field {\n    let mut hash = commitment;\n\n    for i in 0..GLOBAL_DEPTH {\n        let is_right = ((index >> (i as u8)) & 1) == 1;\n        hash = if is_right {\n            Poseidon2::hash([hash_path[i], hash], 2)\n        } else {\n            Poseidon2::hash([hash, hash_path[i]], 2)\n        };\n    }\n    hash\n}",
      "path": "/Users/gary/Desktop/RELIPA/dark_pool/noir_zk/common/src/merkle.nr"
    },
    "73": {
      "source": "use dep::poseidon::poseidon2::Poseidon2;\nuse crate::constants::{\n    MAX_PENDING_ORDER,\n    TOTAL_TOKEN,\n};\n\npub struct Order {\n    pub price: Field,\n    pub quantity: Field,\n    pub direction: Field,\n    pub token_in: Field,\n    pub token_out: Field,\n}\n\npub struct PublicKeyChain {\n    pub pk_root: Field,\n    pub pk_match: Field,  // Public matching key = Poseidon(sk_match)\n    pub nonce: Field,     // Nonce for key rotation (0 for no rotation)\n}\n\npub struct Wallet {\n    pub available_balances: [Field; TOTAL_TOKEN],\n    pub reserved_balances: [Field; TOTAL_TOKEN],\n    pub orders_list: [Field; MAX_PENDING_ORDER],\n    pub fees: Field,\n    pub keys: PublicKeyChain,  // Public key chain\n    pub blinder: Field,        // Randomness for commitment\n}\n\n// Shared helper functions\npub fn compute_wallet_commitment(wallet: Wallet) -> Field {\n    let available_hash = Poseidon2::hash(wallet.available_balances, TOTAL_TOKEN);\n    let reserved_hash = Poseidon2::hash(wallet.reserved_balances, TOTAL_TOKEN);\n    let orders_hash = Poseidon2::hash(wallet.orders_list, MAX_PENDING_ORDER);\n\n    // Hash the public key chain (pk_root, pk_match, nonce)\n    let keys_hash = Poseidon2::hash(\n        [wallet.keys.pk_root, wallet.keys.pk_match, wallet.keys.nonce],\n        3\n    );\n\n    // Commitment = Hash(balances, orders, keys, fees, blinder)\n    Poseidon2::hash(\n        [available_hash, reserved_hash, orders_hash, keys_hash, wallet.fees, wallet.blinder],\n        6\n    )\n}\n\npub fn compute_order_commitment(order: Order) -> Field {\n    let order_array = [order.price, order.quantity, order.direction, order.token_in, order.token_out];\n    Poseidon2::hash(order_array, 5)\n}\n",
      "path": "/Users/gary/Desktop/RELIPA/dark_pool/noir_zk/common/src/data.nr"
    },
    "75": {
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "/Users/gary/nargo/github.com/noir-lang/poseidonv0.1.1/src/poseidon2.nr"
    },
    "83": {
      "source": "use dep::poseidon::poseidon2::Poseidon2;\nuse dep::common::merkle::excute_merkle_root;\nuse dep::common::constants::{\n    GLOBAL_DEPTH,\n    MAX_PENDING_ORDER,\n    TOTAL_TOKEN,\n    TRANSFER_DEPOSIT,\n    TRANSFER_WITHDRAW,\n    SELL,\n    BUY,\n    OP_CREATE_ORDER,\n    OP_CANCEL_ORDER,\n    TOTAL_ORDER_OP,\n};\n\nuse dep::common::data::{\n    Wallet,\n    PublicKeyChain,\n    Order,\n    compute_wallet_commitment,\n    compute_order_commitment,\n};\n\nfn main(\n    // PUBLIC INPUTS\n    old_wallet_commitment: pub Field,\n    new_wallet_commitment: pub Field,\n    old_merkle_root: pub Field,\n\n    // External transfer (public - visible on-chain)\n    transfer_direction: pub Field,\n    transfer_mint: pub Field,\n    transfer_amount: pub Field,\n    operation_type: pub Field,  // 0 = transfer only, 1 = order only, 2 = both\n\n    // PRIVATE WITNESS\n    old_wallet: Wallet,\n    old_index: Field,\n    old_hash_path: [Field; GLOBAL_DEPTH],\n    new_blinder: Field,  // New blinder for new commitment\n\n    // Transfer-specific witness\n    transfer_index: Field,\n\n    // Order-specific witness\n    order_index: Field,\n    order_direction: Field,\n    order_price: Field,\n    order_quantity: Field,\n    order_token_in: Field,\n    order_token_out: Field,\n    order_operation_type: Field,\n) -> pub Field {\n    let operation_type_int = operation_type as u32;\n    assert(operation_type_int <= 2, \"Invalid operation type\");\n\n    // Verify old wallet commitment\n    let computed_old_commitment = compute_wallet_commitment(old_wallet);\n    assert(computed_old_commitment == old_wallet_commitment, \"Old wallet commitment mismatch\");\n\n    // Verify Merkle inclusion proof\n    let old_index_int = old_index as u32;\n    assert(\n        old_merkle_root == excute_merkle_root(old_wallet_commitment, old_hash_path, old_index_int),\n        \"Invalid Merkle proof\"\n    );\n\n    // Transfer validation\n    let transfer_is_active = (operation_type_int == 0) | (operation_type_int == 2);\n    if transfer_is_active {\n        let transfer_index_int = transfer_index as u32;\n        let transfer_mint_int = transfer_mint as u32;\n        let transfer_direction_int = transfer_direction as u32;\n\n        assert(\n            (transfer_direction_int == TRANSFER_DEPOSIT) | (transfer_direction_int == TRANSFER_WITHDRAW),\n            \"Transfer direction must be DEPOSIT or WITHDRAW\"\n        );\n        assert(transfer_index_int < TOTAL_TOKEN, \"Transfer index out of bounds\");\n        assert(transfer_mint_int < TOTAL_TOKEN, \"Transfer mint token out of bounds\");\n\n        let transfer_amount_int = transfer_amount as i32;\n        assert(transfer_amount_int > 0, \"Transfer amount must be positive\");\n    }\n\n    // Order validation\n    let order_is_active = (operation_type_int == 1) | (operation_type_int == 2);\n    if order_is_active {\n        let order_index_int = order_index as u32;\n        let order_token_in_int = order_token_in as u32;\n        let order_token_out_int = order_token_out as u32;\n        let order_operation_type_int = order_operation_type as u32;\n\n        assert(order_operation_type_int < TOTAL_ORDER_OP, \"Invalid order operation type\");\n        assert(order_index_int < MAX_PENDING_ORDER, \"Order index out of bounds\");\n\n        let price_int = order_price as i32;\n        let quantity_int = order_quantity as i32;\n\n        assert(price_int > 0, \"Price must be positive\");\n        assert(quantity_int > 0, \"Quantity must be positive\");\n\n        assert(\n            (order_direction == BUY) | (order_direction == SELL),\n            \"Order direction must be BUY or SELL constant\"\n        );\n\n        assert(order_token_in_int < TOTAL_TOKEN, \"Order token_in out of bounds\");\n        assert(order_token_out_int < TOTAL_TOKEN, \"Order token_out out of bounds\");\n        assert(order_token_in != order_token_out, \"Cannot trade same token\");\n    }\n\n    // Process transfer\n    let mut intermediate_available = old_wallet.available_balances;\n    let mut intermediate_reserved = old_wallet.reserved_balances;\n\n    if transfer_is_active {\n        let transfer_index_int = transfer_index as u32;\n        let transfer_direction_int = transfer_direction as u32;\n\n        if transfer_direction_int == TRANSFER_DEPOSIT {\n            intermediate_available[transfer_index_int] = old_wallet.available_balances[transfer_index_int] + transfer_amount;\n            intermediate_reserved[transfer_index_int] = old_wallet.reserved_balances[transfer_index_int];\n\n            for i in 0..TOTAL_TOKEN {\n                if i != transfer_index_int {\n                    assert(\n                        intermediate_available[i] == old_wallet.available_balances[i],\n                        \"Available balance changed unexpectedly during deposit\"\n                    );\n                    assert(\n                        intermediate_reserved[i] == old_wallet.reserved_balances[i],\n                        \"Reserved balance changed unexpectedly during deposit\"\n                    );\n                }\n            }\n        } else {\n            let check_amount = old_wallet.available_balances[transfer_index_int].lt(transfer_amount);\n            assert(!check_amount, \"Insufficient balance for withdrawal\");\n\n            intermediate_available[transfer_index_int] = old_wallet.available_balances[transfer_index_int] - transfer_amount;\n            intermediate_reserved[transfer_index_int] = old_wallet.reserved_balances[transfer_index_int];\n\n            assert(old_wallet.fees == 0, \"Must settle fees before withdrawal\");\n\n            for i in 0..TOTAL_TOKEN {\n                if i != transfer_index_int {\n                    assert(\n                        intermediate_available[i] == old_wallet.available_balances[i],\n                        \"Available balance changed unexpectedly during withdrawal\"\n                    );\n                    assert(\n                        intermediate_reserved[i] == old_wallet.reserved_balances[i],\n                        \"Reserved balance changed unexpectedly during withdrawal\"\n                    );\n                }\n            }\n        }\n    }\n\n    // Process order\n    let mut final_available = intermediate_available;\n    let mut final_reserved = intermediate_reserved;\n    let mut final_orders = old_wallet.orders_list;\n\n    if order_is_active {\n        let order_index_int = order_index as u32;\n        let order_token_out_int = order_token_out as u32;\n        let order_operation_type_int = order_operation_type as u32;\n\n        if order_operation_type_int == OP_CREATE_ORDER {\n            assert(old_wallet.orders_list[order_index_int] == 0, \"Order slot must be empty\");\n\n            if order_direction == SELL {\n                let check_amount = intermediate_available[order_token_out_int].lt(order_quantity);\n                assert(!check_amount, \"Insufficient available balance for order\");\n\n                final_available[order_token_out_int] = intermediate_available[order_token_out_int] - order_quantity;\n                final_reserved[order_token_out_int] = intermediate_reserved[order_token_out_int] + order_quantity;\n            } else {\n                // BUY order: calculate total cost (integer only, no decimals)\n                let total_cost = order_price * order_quantity;\n                assert(\n                    total_cost.lt(order_price) == false,\n                    \"Order cost overflow - price * quantity too large\"\n                );\n\n                let check_amount = intermediate_available[order_token_out_int].lt(total_cost);\n                assert(!check_amount, \"Insufficient available balance for order\");\n\n                final_available[order_token_out_int] = intermediate_available[order_token_out_int] - total_cost;\n                final_reserved[order_token_out_int] = intermediate_reserved[order_token_out_int] + total_cost;\n            }\n\n            for i in 0..TOTAL_TOKEN {\n                if i != order_token_out_int {\n                    assert(\n                        final_available[i] == intermediate_available[i],\n                        \"Available balance changed unexpectedly during order creation\"\n                    );\n                    assert(\n                        final_reserved[i] == intermediate_reserved[i],\n                        \"Reserved balance changed unexpectedly during order creation\"\n                    );\n                }\n            }\n\n            let new_order = Order {\n                price: order_price,\n                quantity: order_quantity,\n                direction: order_direction,\n                token_in: order_token_in,\n                token_out: order_token_out,\n            };\n            let new_order_commitment = compute_order_commitment(new_order);\n\n            final_orders[order_index_int] = new_order_commitment;\n\n            for i in 0..MAX_PENDING_ORDER {\n                if i != order_index_int {\n                    assert(\n                        final_orders[i] == old_wallet.orders_list[i],\n                        \"Other orders changed unexpectedly during order creation\"\n                    );\n                }\n            }\n\n        } else {\n            assert(order_operation_type_int == OP_CANCEL_ORDER, \"Invalid order operation for cancellation\");\n            assert(old_wallet.orders_list[order_index_int] != 0, \"Order slot must be filled for cancellation\");\n\n            let expected_order = Order {\n                price: order_price,\n                quantity: order_quantity,\n                direction: order_direction,\n                token_in: order_token_in,\n                token_out: order_token_out,\n            };\n            let expected_order_commitment = compute_order_commitment(expected_order);\n            assert(\n                old_wallet.orders_list[order_index_int] == expected_order_commitment,\n                \"Order details mismatch - cancellation data does not match existing order\"\n            );\n\n            if order_direction == SELL {\n                final_available[order_token_out_int] = intermediate_available[order_token_out_int] + order_quantity;\n                final_reserved[order_token_out_int] = intermediate_reserved[order_token_out_int] - order_quantity;\n            } else {\n                // BUY cancellation: return reserved cost to available\n                let total_cost = order_price * order_quantity;\n                assert(\n                    total_cost.lt(order_price) == false,\n                    \"Order cost overflow during cancellation\"\n                );\n\n                final_available[order_token_out_int] = intermediate_available[order_token_out_int] + total_cost;\n                final_reserved[order_token_out_int] = intermediate_reserved[order_token_out_int] - total_cost;\n            }\n\n            for i in 0..TOTAL_TOKEN {\n                if i != order_token_out_int {\n                    assert(\n                        final_available[i] == intermediate_available[i],\n                        \"Available balance changed unexpectedly during order cancellation\"\n                    );\n                    assert(\n                        final_reserved[i] == intermediate_reserved[i],\n                        \"Reserved balance changed unexpectedly during order cancellation\"\n                    );\n                }\n            }\n            final_orders[order_index_int] = 0;\n            for i in 0..MAX_PENDING_ORDER {\n                if i != order_index_int {\n                    assert(\n                        final_orders[i] == old_wallet.orders_list[i],\n                        \"Other orders changed unexpectedly during order cancellation\"\n                    );\n                }\n            }\n        }\n    }\n\n    // Verify no changes if no operations\n    if !transfer_is_active & !order_is_active {\n        for i in 0..TOTAL_TOKEN {\n            assert(\n                final_available[i] == old_wallet.available_balances[i],\n                \"Available balance should not change without transfer or order\"\n            );\n            assert(\n                final_reserved[i] == old_wallet.reserved_balances[i],\n                \"Reserved balance should not change without transfer or order\"\n            );\n        }\n        for i in 0..MAX_PENDING_ORDER {\n            assert(\n                final_orders[i] == old_wallet.orders_list[i],\n                \"Orders should not change without order operation\"\n            );\n        }\n    }\n\n    // Create new wallet with incremented nonce\n    let new_nonce = old_wallet.keys.nonce + 1;\n\n    // Verify new blinder is derived correctly\n    let expected_new_blinder = Poseidon2::hash([old_wallet.blinder, new_nonce], 2);\n    assert(expected_new_blinder == new_blinder, \"New blinder derivation mismatch\");\n\n    let new_wallet = Wallet {\n        available_balances: final_available,\n        reserved_balances: final_reserved,\n        orders_list: final_orders,\n        fees: old_wallet.fees,  // Fees unchanged in update (only in match_settle)\n        keys: PublicKeyChain {\n            pk_root: old_wallet.keys.pk_root,\n            pk_match: old_wallet.keys.pk_match,\n            nonce: new_nonce,\n        },\n        blinder: new_blinder,\n    };\n\n    let computed_new_commitment = compute_wallet_commitment(new_wallet);\n    assert(computed_new_commitment == new_wallet_commitment, \"New wallet commitment mismatch\");\n\n    // Compute nullifier\n    let nullifier = Poseidon2::hash([old_wallet.blinder, old_wallet_commitment], 2);\n\n    nullifier\n}\n",
      "path": "/Users/gary/Desktop/RELIPA/dark_pool/noir_zk/wallet_update_state/src/main.nr"
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "lt_32_hint",
    "decompose_hint",
    "lte_16_hint",
    "directive_integer_quotient",
    "directive_invert"
  ]
}