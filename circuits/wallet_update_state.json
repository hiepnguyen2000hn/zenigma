{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":11932972071011502561,"abi":{"parameters":[{"name":"old_wallet_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"new_wallet_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"old_merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"transfer_direction","type":{"kind":"field"},"visibility":"public"},{"name":"transfer_mint","type":{"kind":"field"},"visibility":"public"},{"name":"transfer_amount","type":{"kind":"field"},"visibility":"public"},{"name":"operation_type","type":{"kind":"field"},"visibility":"public"},{"name":"old_wallet","type":{"kind":"struct","path":"common::data::Wallet","fields":[{"name":"available_balances","type":{"kind":"array","length":10,"type":{"kind":"field"}}},{"name":"reserved_balances","type":{"kind":"array","length":10,"type":{"kind":"field"}}},{"name":"orders_list","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"fees","type":{"kind":"field"}},{"name":"keys","type":{"kind":"struct","path":"common::data::PublicKeyChain","fields":[{"name":"pk_root","type":{"kind":"field"}},{"name":"pk_match","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]}},{"name":"blinder","type":{"kind":"field"}}]},"visibility":"private"},{"name":"old_index","type":{"kind":"field"},"visibility":"private"},{"name":"old_hash_path","type":{"kind":"array","length":16,"type":{"kind":"field"}},"visibility":"private"},{"name":"new_blinder","type":{"kind":"field"},"visibility":"private"},{"name":"transfer_index","type":{"kind":"field"},"visibility":"private"},{"name":"order_index","type":{"kind":"field"},"visibility":"private"},{"name":"order_direction","type":{"kind":"field"},"visibility":"private"},{"name":"order_price","type":{"kind":"field"},"visibility":"private"},{"name":"order_quantity","type":{"kind":"field"},"visibility":"private"},{"name":"order_token_in","type":{"kind":"field"},"visibility":"private"},{"name":"order_token_out","type":{"kind":"field"},"visibility":"private"},{"name":"order_operation_type","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"25":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"72":{"source":"use dep::poseidon::poseidon2::Poseidon2;\nuse crate::constants::GLOBAL_DEPTH;\n\npub fn excute_merkle_root(\n    commitment: Field,\n    hash_path: [Field; GLOBAL_DEPTH],\n    index: u32,\n) -> Field {\n    let mut hash = commitment;\n\n    for i in 0..GLOBAL_DEPTH {\n        let is_right = ((index >> (i as u8)) & 1) == 1;\n        hash = if is_right {\n            Poseidon2::hash([hash_path[i], hash], 2)\n        } else {\n            Poseidon2::hash([hash, hash_path[i]], 2)\n        };\n    }\n    hash\n}","path":"/Users/gary/Desktop/RELIPA/dark_pool/noir_zk/common/src/merkle.nr"},"73":{"source":"use dep::poseidon::poseidon2::Poseidon2;\nuse crate::constants::{\n    MAX_PENDING_ORDER,\n    TOTAL_TOKEN,\n};\n\npub struct Order {\n    pub price: Field,\n    pub quantity: Field,\n    pub direction: Field,\n    pub token_in: Field,\n    pub token_out: Field,\n}\n\npub struct PublicKeyChain {\n    pub pk_root: Field,\n    pub pk_match: Field,  // Public matching key = Poseidon(sk_match)\n    pub nonce: Field,     // Nonce for key rotation (0 for no rotation)\n}\n\npub struct Wallet {\n    pub available_balances: [Field; TOTAL_TOKEN],\n    pub reserved_balances: [Field; TOTAL_TOKEN],\n    pub orders_list: [Field; MAX_PENDING_ORDER],\n    pub fees: Field,\n    pub keys: PublicKeyChain,  // Public key chain\n    pub blinder: Field,        // Randomness for commitment\n}\n\n// Shared helper functions\npub fn compute_wallet_commitment(wallet: Wallet) -> Field {\n    let available_hash = Poseidon2::hash(wallet.available_balances, TOTAL_TOKEN);\n    let reserved_hash = Poseidon2::hash(wallet.reserved_balances, TOTAL_TOKEN);\n    let orders_hash = Poseidon2::hash(wallet.orders_list, MAX_PENDING_ORDER);\n\n    // Hash the public key chain (pk_root, pk_match, nonce)\n    let keys_hash = Poseidon2::hash(\n        [wallet.keys.pk_root, wallet.keys.pk_match, wallet.keys.nonce],\n        3\n    );\n\n    // Commitment = Hash(balances, orders, keys, fees, blinder)\n    Poseidon2::hash(\n        [available_hash, reserved_hash, orders_hash, keys_hash, wallet.fees, wallet.blinder],\n        6\n    )\n}\n\npub fn compute_order_commitment(order: Order) -> Field {\n    let order_array = [order.price, order.quantity, order.direction, order.token_in, order.token_out];\n    Poseidon2::hash(order_array, 5)\n}\n","path":"/Users/gary/Desktop/RELIPA/dark_pool/noir_zk/common/src/data.nr"},"75":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/gary/nargo/github.com/noir-lang/poseidonv0.1.1/src/poseidon2.nr"},"83":{"source":"use dep::poseidon::poseidon2::Poseidon2;\nuse dep::common::merkle::excute_merkle_root;\nuse dep::common::constants::{\n    GLOBAL_DEPTH,\n    MAX_PENDING_ORDER,\n    TOTAL_TOKEN,\n    TRANSFER_DEPOSIT,\n    TRANSFER_WITHDRAW,\n    SELL,\n    BUY,\n    OP_CREATE_ORDER,\n    OP_CANCEL_ORDER,\n    TOTAL_ORDER_OP,\n    PERCISION\n};\n\nuse dep::common::data::{\n    Wallet,\n    PublicKeyChain,\n    Order,\n    compute_wallet_commitment,\n    compute_order_commitment,\n};\n\nfn main(\n    // PUBLIC INPUTS\n    old_wallet_commitment: pub Field,\n    new_wallet_commitment: pub Field,\n    old_merkle_root: pub Field,\n\n    // External transfer (public - visible on-chain)\n    transfer_direction: pub Field,\n    transfer_mint: pub Field,\n    transfer_amount: pub Field,\n    operation_type: pub Field,  // 0 = transfer only, 1 = order only, 2 = both\n\n    // PRIVATE WITNESS\n    old_wallet: Wallet,\n    old_index: Field,\n    old_hash_path: [Field; GLOBAL_DEPTH],\n    new_blinder: Field,  // New blinder for new commitment\n\n    // Transfer-specific witness\n    transfer_index: Field,\n\n    // Order-specific witness\n    order_index: Field,\n    order_direction: Field,\n    order_price: Field,\n    order_quantity: Field,\n    order_token_in: Field,\n    order_token_out: Field,\n    order_operation_type: Field,\n) -> pub Field {\n    let operation_type_int = operation_type as u32;\n    assert(operation_type_int <= 2, \"Invalid operation type\");\n\n    // Verify old wallet commitment\n    let computed_old_commitment = compute_wallet_commitment(old_wallet);\n    assert(computed_old_commitment == old_wallet_commitment, \"Old wallet commitment mismatch\");\n\n    // Verify Merkle inclusion proof\n    let old_index_int = old_index as u32;\n    assert(\n        old_merkle_root == excute_merkle_root(old_wallet_commitment, old_hash_path, old_index_int),\n        \"Invalid Merkle proof\"\n    );\n\n    // Transfer validation\n    let transfer_is_active = (operation_type_int == 0) | (operation_type_int == 2);\n    if transfer_is_active {\n        let transfer_index_int = transfer_index as u32;\n        let transfer_mint_int = transfer_mint as u32;\n        let transfer_direction_int = transfer_direction as u32;\n\n        assert(\n            (transfer_direction_int == TRANSFER_DEPOSIT) | (transfer_direction_int == TRANSFER_WITHDRAW),\n            \"Transfer direction must be DEPOSIT or WITHDRAW\"\n        );\n        assert(transfer_index_int < TOTAL_TOKEN, \"Transfer index out of bounds\");\n        assert(transfer_mint_int < TOTAL_TOKEN, \"Transfer mint token out of bounds\");\n\n        let transfer_amount_int = transfer_amount as i32;\n        assert(transfer_amount_int > 0, \"Transfer amount must be positive\");\n    }\n\n    // Order validation\n    let order_is_active = (operation_type_int == 1) | (operation_type_int == 2);\n    if order_is_active {\n        let order_index_int = order_index as u32;\n        let order_token_in_int = order_token_in as u32;\n        let order_token_out_int = order_token_out as u32;\n        let order_operation_type_int = order_operation_type as u32;\n\n        assert(order_operation_type_int < TOTAL_ORDER_OP, \"Invalid order operation type\");\n        assert(order_index_int < MAX_PENDING_ORDER, \"Order index out of bounds\");\n\n        let price_int = order_price as i32;\n        let quantity_int = order_quantity as i32;\n\n        assert(price_int > 0, \"Price must be positive\");\n        assert(quantity_int > 0, \"Quantity must be positive\");\n\n        assert(\n            (order_direction == BUY) | (order_direction == SELL),\n            \"Order direction must be BUY or SELL constant\"\n        );\n\n        assert(order_token_in_int < TOTAL_TOKEN, \"Order token_in out of bounds\");\n        assert(order_token_out_int < TOTAL_TOKEN, \"Order token_out out of bounds\");\n        assert(order_token_in != order_token_out, \"Cannot trade same token\");\n    }\n\n    // Process transfer\n    let mut intermediate_available = old_wallet.available_balances;\n    let mut intermediate_reserved = old_wallet.reserved_balances;\n\n    if transfer_is_active {\n        let transfer_index_int = transfer_index as u32;\n        let transfer_direction_int = transfer_direction as u32;\n\n        if transfer_direction_int == TRANSFER_DEPOSIT {\n            intermediate_available[transfer_index_int] = old_wallet.available_balances[transfer_index_int] + transfer_amount;\n            intermediate_reserved[transfer_index_int] = old_wallet.reserved_balances[transfer_index_int];\n\n            for i in 0..TOTAL_TOKEN {\n                if i != transfer_index_int {\n                    assert(\n                        intermediate_available[i] == old_wallet.available_balances[i],\n                        \"Available balance changed unexpectedly during deposit\"\n                    );\n                    assert(\n                        intermediate_reserved[i] == old_wallet.reserved_balances[i],\n                        \"Reserved balance changed unexpectedly during deposit\"\n                    );\n                }\n            }\n        } else {\n            let check_amount = old_wallet.available_balances[transfer_index_int].lt(transfer_amount);\n            assert(!check_amount, \"Insufficient balance for withdrawal\");\n\n            intermediate_available[transfer_index_int] = old_wallet.available_balances[transfer_index_int] - transfer_amount;\n            intermediate_reserved[transfer_index_int] = old_wallet.reserved_balances[transfer_index_int];\n\n            assert(old_wallet.fees == 0, \"Must settle fees before withdrawal\");\n\n            for i in 0..TOTAL_TOKEN {\n                if i != transfer_index_int {\n                    assert(\n                        intermediate_available[i] == old_wallet.available_balances[i],\n                        \"Available balance changed unexpectedly during withdrawal\"\n                    );\n                    assert(\n                        intermediate_reserved[i] == old_wallet.reserved_balances[i],\n                        \"Reserved balance changed unexpectedly during withdrawal\"\n                    );\n                }\n            }\n        }\n    }\n\n    // Process order\n    let mut final_available = intermediate_available;\n    let mut final_reserved = intermediate_reserved;\n    let mut final_orders = old_wallet.orders_list;\n\n    if order_is_active {\n        let order_index_int = order_index as u32;\n        let order_token_out_int = order_token_out as u32;\n        let order_operation_type_int = order_operation_type as u32;\n\n        if order_operation_type_int == OP_CREATE_ORDER {\n            assert(old_wallet.orders_list[order_index_int] == 0, \"Order slot must be empty\");\n\n            if order_direction == SELL {\n                let order_quantity_scaled: Field = PERCISION * order_quantity;\n                let check_amount = intermediate_available[order_token_out_int].lt(order_quantity_scaled);\n                assert(!check_amount, \"Insufficient available balance for order\");\n                final_available[order_token_out_int] = intermediate_available[order_token_out_int] - order_quantity_scaled;\n                final_reserved[order_token_out_int] = intermediate_reserved[order_token_out_int] + order_quantity_scaled;\n            } else {\n                // BUY order: calculate total cost (integer only, no decimals)\n                let total_cost = order_price * order_quantity;\n                assert(\n                    total_cost.lt(order_price) == false,\n                    \"Order cost overflow - price * quantity too large\"\n                );\n\n                let check_amount = intermediate_available[order_token_out_int].lt(total_cost);\n                assert(!check_amount, \"Insufficient available balance for order\");\n\n                final_available[order_token_out_int] = intermediate_available[order_token_out_int] - total_cost;\n                final_reserved[order_token_out_int] = intermediate_reserved[order_token_out_int] + total_cost;\n            }\n\n            for i in 0..TOTAL_TOKEN {\n                if i != order_token_out_int {\n                    assert(\n                        final_available[i] == intermediate_available[i],\n                        \"Available balance changed unexpectedly during order creation\"\n                    );\n                    assert(\n                        final_reserved[i] == intermediate_reserved[i],\n                        \"Reserved balance changed unexpectedly during order creation\"\n                    );\n                }\n            }\n\n            let new_order = Order {\n                price: order_price,\n                quantity: order_quantity,\n                direction: order_direction,\n                token_in: order_token_in,\n                token_out: order_token_out,\n            };\n            let new_order_commitment = compute_order_commitment(new_order);\n\n            final_orders[order_index_int] = new_order_commitment;\n\n            for i in 0..MAX_PENDING_ORDER {\n                if i != order_index_int {\n                    assert(\n                        final_orders[i] == old_wallet.orders_list[i],\n                        \"Other orders changed unexpectedly during order creation\"\n                    );\n                }\n            }\n\n        } else {\n            assert(order_operation_type_int == OP_CANCEL_ORDER, \"Invalid order operation for cancellation\");\n            assert(old_wallet.orders_list[order_index_int] != 0, \"Order slot must be filled for cancellation\");\n\n            let expected_order = Order {\n                price: order_price,\n                quantity: order_quantity,\n                direction: order_direction,\n                token_in: order_token_in,\n                token_out: order_token_out,\n            };\n            let expected_order_commitment = compute_order_commitment(expected_order);\n            assert(\n                old_wallet.orders_list[order_index_int] == expected_order_commitment,\n                \"Order details mismatch - cancellation data does not match existing order\"\n            );\n\n            if order_direction == SELL {\n                let order_quantity_scaled: Field = PERCISION * order_quantity;\n                final_available[order_token_out_int] = intermediate_available[order_token_out_int] + order_quantity_scaled;\n                final_reserved[order_token_out_int] = intermediate_reserved[order_token_out_int] - order_quantity_scaled;\n            } else {\n                // BUY cancellation: return reserved cost to available\n                let total_cost = order_price * order_quantity;\n                assert(\n                    total_cost.lt(order_price) == false,\n                    \"Order cost overflow during cancellation\"\n                );\n\n                final_available[order_token_out_int] = intermediate_available[order_token_out_int] + total_cost;\n                final_reserved[order_token_out_int] = intermediate_reserved[order_token_out_int] - total_cost;\n            }\n\n            for i in 0..TOTAL_TOKEN {\n                if i != order_token_out_int {\n                    assert(\n                        final_available[i] == intermediate_available[i],\n                        \"Available balance changed unexpectedly during order cancellation\"\n                    );\n                    assert(\n                        final_reserved[i] == intermediate_reserved[i],\n                        \"Reserved balance changed unexpectedly during order cancellation\"\n                    );\n                }\n            }\n            final_orders[order_index_int] = 0;\n            for i in 0..MAX_PENDING_ORDER {\n                if i != order_index_int {\n                    assert(\n                        final_orders[i] == old_wallet.orders_list[i],\n                        \"Other orders changed unexpectedly during order cancellation\"\n                    );\n                }\n            }\n        }\n    }\n\n    // Verify no changes if no operations\n    if !transfer_is_active & !order_is_active {\n        for i in 0..TOTAL_TOKEN {\n            assert(\n                final_available[i] == old_wallet.available_balances[i],\n                \"Available balance should not change without transfer or order\"\n            );\n            assert(\n                final_reserved[i] == old_wallet.reserved_balances[i],\n                \"Reserved balance should not change without transfer or order\"\n            );\n        }\n        for i in 0..MAX_PENDING_ORDER {\n            assert(\n                final_orders[i] == old_wallet.orders_list[i],\n                \"Orders should not change without order operation\"\n            );\n        }\n    }\n\n    // Create new wallet with incremented nonce\n    let new_nonce = old_wallet.keys.nonce + 1;\n\n    // Verify new blinder is derived correctly\n    let expected_new_blinder = Poseidon2::hash([old_wallet.blinder, new_nonce], 2);\n    assert(expected_new_blinder == new_blinder, \"New blinder derivation mismatch\");\n\n    let new_wallet = Wallet {\n        available_balances: final_available,\n        reserved_balances: final_reserved,\n        orders_list: final_orders,\n        fees: old_wallet.fees,  // Fees unchanged in update (only in match_settle)\n        keys: PublicKeyChain {\n            pk_root: old_wallet.keys.pk_root,\n            pk_match: old_wallet.keys.pk_match,\n            nonce: new_nonce,\n        },\n        blinder: new_blinder,\n    };\n\n    let computed_new_commitment = compute_wallet_commitment(new_wallet);\n    assert(computed_new_commitment == new_wallet_commitment, \"New wallet commitment mismatch\");\n\n    // Compute nullifier\n    let nullifier = Poseidon2::hash([old_wallet.blinder, old_wallet_commitment], 2);\n\n    nullifier\n}\n","path":"/Users/gary/Desktop/RELIPA/dark_pool/noir_zk/wallet_update_state/src/main.nr"}},"names":["main"],"brillig_names":["lt_32_hint","decompose_hint","lte_16_hint","directive_integer_quotient","directive_invert"]}